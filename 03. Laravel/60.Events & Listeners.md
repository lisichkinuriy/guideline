# Events & Listeners

- Event регистрируется внутри доменных методов и диспетчится в момент коммита UnitOfWork.
- Event это всегда Доменный Event
- Event это способ передачи управления из одного модуля (крупного блока кода) в другой
- Общение между модулями происходит через очереди, поэтому ответственность Listener - это только Dispatch необходимой Джобы.

Почему мы не используем евенты для передачи управления внутри одного модуля?  
Loose coupling - high cohesion.  
Event - инструмент для обеспечения Loose coupling. 
Внутри одного модуля "Loose coupling" - не нужен, модуль - это структура высокой связности.
Поэтому - не усложняем код. Используем event для передачи управления между модулями.     



Плохой пример
```php
$card->issue();
$card->save();
CardIssueCreated::dispatch($card);
```

Хороший пример
```php

$card->issue();
$uow->add($card)->commit();

trait CardDomain {
    public function issue(): self {
        $this->state = "some value";
        $this->dispatchDomainEvent(CardIssueCreated::class, $this);
        return $this;
    }
}
```

Пример Listener
```php
class PostbackListener
{
    public function handle(CardIssueCreated|CardIssueFailed $event): void
    {
        InitPostbackJob::dispatch($event->card->getID());
    }
}
```

Пример юнит теста
```php
public function test_event(): void
{
    Event::fake();
    Event::assertListening(CardIssueCreated::class, PostbackListener::class);
    Event::assertListening(CardIssueFailed::class, PostbackListener::class);
}
```


Пример юнит теста
```php
public function test_listener(): void
{
    Queue::fake();
    $event = new CardIssueCreated();
    $listener = new PostbackListener();
    $listener->handle($event);
    
    Queue::assertPushed(InitPostbackJob::class);
}
```
