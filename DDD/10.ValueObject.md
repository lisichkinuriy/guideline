# VO

- проверяет сам себя на валидность, VO без ограничений не бывает, если бизнес сообщает что ограничений нет - это значит только то, что они ещё не продуманы.
    входные данные проверяем в три этапа:
    1. проверка размера данных
    2. лексическая проверка - содержит только допустимые символы ( regex )
    3. семантическая проверка - данные имеют смысл

- имеет вспомогательные static конструкторы
- знает как сравнить себя с другим VO
- при присутствии в реквесте знает как провалидировать себя в Request
- умеет себя зафейкать
- знает о константах своего типа
- может содержать другие VO (если у нас JSON поле в базе данных)

простой VO 
```php
final readonly class PaymentBankAccount
{
    public function __construct(
        public string $value
    ) {
        if ($this->validate($value) === false) {
            throw ValidationException::withMessages([
                'PaymentBankAccount' => 'Некорректный PaymentBankAccount',
            ]);
        }
    }

    public static function validate(string $value): bool
    {
        $s = str($value);
        if ($s->length() !== 20) {
            return false;
        }

        if ($s->isMatch('/^\d+$/') === false) {
            return false;
        }

        $first_3 = $s->substr(0, 3);
        $allowed = collect(['407', '408', '423']);
        if ($allowed->doesntContain($first_3)) {
            return false;
        }

        return true;
    }

    public static function fake(): self
    {
        return new self('40700000000000000000');
    }

    public function equals(self $other): bool
    {
        return $this->value === $other->value;
    }
}
```



VO состоящий из VO (хранится в базе как JSON поле)
```php
final readonly class RequisiteCard
{
    public const PAN = 'pan';
    public const EXPIRE = 'expire';

    public function __construct(
        public RequisitePAN $PAN,
        public RequisiteExpire $expire
    ) {}

    public static function fromArray(array $requisites): RequisiteCard
    {
        return new self(new RequisitePAN($requisites[self::PAN]), new RequisiteExpire($requisites[self::EXPIRE]));
    }

    public static function fake()
    {
        return new self(RequisitePAN::fake(), RequisiteExpire::fake());
    }

    public static function toBeFailedAtInit(): self
    {
        return new self(RequisitePAN::sandboxPANToBeFailed(), RequisiteExpire::fake());
    }

    public function equals(self $other): bool
    {
        return $this->PAN->equals($other->PAN) && $this->expire->equals($other->expire);
    }

    public function hash(): string
    {
        $str = $this->PAN->value.$this->expire->value;

        return ReceiverDomain::hash($str);
    }

    public function toArray(): array
    {
        return [
            self::PAN => $this->PAN->value,
            self::EXPIRE => $this->expire->value,
        ];
    }
}
```